#+TITLE: Présidentielles 2022
#+SUBTITLE: Cahier de laboratoire
#+STARTUP: hideblocks

#+PROPERTY: header-args :eval never-export :exports both :results output drawer replace
#+PROPERTY: header-args+ :session survey-book-models :comments yes

Dans ce document nous recensons les analyses que nous avons pu faire au jour le jours.

#+description: Load the virtual environment
#+begin_src elisp :session :exports none
(pyvenv-workon 'polls)
#+end_src

#+RESULTS:

#+description: Import needed libraries
#+begin_src python :session :results silent :exports none
import src.intentions
import numpy as np
import pymc3 as pm
#+end_src

* Color schemes :noexport:

#+description: Darker colors from coolors.com
#+begin_src python :session :results silent :exports none
colors = {
    "Poutou": "#DD1C1A",
    "Arthaud": "#DD1C1A",
    "Roussel": "#DD1C1A",
    "Mélenchon": "#E85D75",
    "Hidalgo": "#FF7F11",
    "Jadot": "#B2C9AB",
    "Montebourg": "#FF7F11",
    "Macron": "#748CAB",
    "Pécresse": "#748CAB",
    "Lassalle": "#748CAB",
    "Zemmour": "#080708",
    "Peuvent changer d'avis": "#080708",
    "Dupont-Aignan": "#2E294E",
    "Le Pen": "#292F36",
}
#+end_src

* Décembre 2021
** Odoxa 09.12
:PROPERTIES:
    :BEGIN: 07/12/2021
    :END: 09/12/2021
    :BASE: Comptant aller voter
:END:

Premier sondage d'Odoxa après l'officialisation de la candidature de Pécresse pour Les Républicains.

#+begin_src python :session :results silent
num_exprimes = 1391
precision = 0.25
resultats = {
    "Arthaud": 1,
    "Poutou": 1.5,
    "Roussel": 2,
    "Mélenchon": 10,
    "Montebourg": 1,
    "Hidalgo": 3,
    "Jadot": 6,
    "Macron": 24,
    "Pécresse": 19,
    "Dupont-Aignan": 2.5,
    "Zemmour": 12,
    "Le Pen": 17,
    "Lassalle": 1,
}
assert sum(list(resultats.values())) == 100
#+end_src

#+begin_src python :session :async true :results silent
with pm.Model() as bva:
    prior_intentions = np.array(
        [1, 1.5, 2, 10, 1, 3, 6, 24, 19, 2.5, 12, 17, 1]
    ) * 0.1
    results_r = np.array(list(resultats.values())) / 100
    precision_r = precision / 100

    p = pm.Dirichlet("intentions", prior_intentions)  # Prior too vague?
    r = pm.Dirichlet("real_ratios", num_exprimes * p, observed=results_r)

    trace = pm.sample()
#+end_src

#+begin_src python :session :results file :exports results :var filename=(org-babel-temp-file "figure" ".png")
import arviz as az
import matplotlib.pyplot as plt

az.plot_trace(trace)
plt.savefig(filename, bbox_inches='tight')
filename
#+end_src

#+RESULTS:
[[file:/tmp/babel-5lYmj3/figureEAx2hR.png]]


#+begin_src python :session :results file :exports both :var filename=(org-babel-temp-file "figure" ".png")
intentions_r = {k: trace['intentions'][:,i] for i,k in enumerate(resultats.keys())}
fig = src.intentions.plot(
    intentions_r,
    colors,
    "09/12/2021",
    "Odoxa pour L'OBS et mascaret",
    title="Intentions de vote au premier tour",
    sample_size=num_exprimes,
    base="Comptant aller voter et exprimant une opinion",
    logo_path="~/org/roam/images/logo.png"
)
plt.tight_layout()
plt.savefig(filename, dpi=600, bbox_inches="tight")
filename
#+end_src
#+attr_org: :width 500
#+RESULTS:
[[file:/tmp/babel-5lYmj3/figure7ejmnm.png]]


Odoxa ne spécifie pas le % de gens qui sont surs de leur choix, impossible de donner d'autre information.

** BVA 08.12
:PROPERTIES:
    :BEGIN: 06/12/2021
    :END: 08/12/2021
    :BASE: Certaines d'aller voter
:END:

#+begin_src python :session
num_exprimes = 894
precision = 0.25
resultats = {
    "Arthaud": .5,
    "Poutou": 1.5,
    "Mélenchon": 9,
    "Roussel": 2.5,
    "Montebourg": 1,
    "Hidalgo": 5,
    "Jadot": 7,
    "Macron": 24,
    "Pécresse": 17,
    "Dupont-Aignan": 2.5,
    "Zemmour": 13,
    "Le Pen": 16,
    "Lassalle": 1,
}
assert sum(list(resultats.values())) == 100
#+end_src

#+RESULTS:

#+begin_src python :session :async true
with pm.Model() as bva:
    prior_intentions = np.array(
        [.5, 1.5, 9, 2.5, 1, 5, 7, 24, 17, 2.5, 13, 16, 1]
    )
    results_r = np.array(list(resultats.values())) / 100
    precision_r = precision / 100

    p = pm.Dirichlet("intentions", prior_intentions)  # Prior too vague?
    r = pm.Dirichlet("real_ratios", num_exprimes * p, observed=results_r)

    trace = pm.sample()
#+end_src


#+RESULTS:

#+begin_src python :session :results file :exports results :var filename=(org-babel-temp-file "figure" ".png")
import arviz as az
import matplotlib.pyplot as plt
az.plot_trace(trace)
plt.savefig(filename, bbox_inches='tight')
filename
#+end_src

#+RESULTS:
[[file:/tmp/babel-VWjkW3/figure0p2VLy.png]]

#+begin_src python :session :results file :exports both :var filename=(org-babel-temp-file "figure" ".png")
intentions_r = {k: trace['intentions'][:,i] for i,k in enumerate(resultats.keys())}
fig = src.intentions.plot(
    intentions_r,
    colors,
    "08/12/2021",
    "BVA pour Orange et RTL",
    title="Intentions de vote au premier tour",
    sample_size=num_exprimes,
    base="Certains d'aller voter et exprimant une opinion",
    logo_path="~/org/roam/images/logo.png"
)
plt.tight_layout()
plt.savefig(filename, dpi=600, bbox_inches="tight")
filename
#+end_src

#+attr_org: :width 600
#+RESULTS:
[[file:/tmp/babel-VWjkW3/figurePTbhcD.png]]

Il serait quand même judicieux de mettre les gens n'ayant pas exprimé d'opinion sur les graphes.

*** Intentions de vote des gens sûrs leur choix

#+begin_src python :session :results silent
import math

certains_total = 71
certains = {
    "Mélenchon": 74,
    "Hidalgo": 51,
    "Jadot": 48,
    "Macron": 73,
    "Pécresse": 60,
    "Zemmour": 65,
    "Le Pen": 74,
}

# On fait l'hypothèse (assez bien vérifié quand on regarde les chiffres)
resultats_certains = {}
total = 0
remaining = 0
for i, c in enumerate(resultats):
    try:
        num_certains = trace['intentions'][:, i] * certains[c] / 100
        resultats_certains[c] = num_certains
        total += num_certains
    except:
        resultats_certains[c] = trace['intentions'][:, i]
        total += trace['intentions'][:, i]

for c in resultats:
    resultats_certains[c] /= total
#+end_src

#+begin_src python :session :results file :exports both :var filename=(org-babel-temp-file "figure" ".png")
intentions_r = {k: v for k, v in resultats_certains.items()}
fig = src.intentions.plot(
    intentions_r,
    colors,
    "08/12/2021",
    "BVA pour Orange et RTL",
    title="Intentions de vote au premier tour",
    sample_size=num_exprimes,
    base="Certains d'aller voter et sûrs de leur choix",
    logo_path="~/org/roam/images/logo.png"
)
plt.tight_layout()
plt.savefig(filename, dpi=600, bbox_inches="tight")
filename
#+end_src

#+attr_org: :width 500
#+RESULTS:
[[file:/tmp/babel-OuSpkx/figurehbOufB.png]]

*** Tenir compte des erreurs d'arrondi pour les incertitudes :model:

Les instituts de sondages ne donnent pas les valeurs des intentions brutes mais il les arrondissent à l'entier le plus proche (ou demi-point de pourcentage le plus proche) ce qui induit une incertitude supplémentaire.

La seule façon vraiment propre de tenir compte des ces erreurs d'arrondi dans PyMC3 est de travailler avec la cumulative (cf [[https://mc-stan.org/docs/2_27/stan-users-guide/bayesian-measurement-error-model.html][cette page du manuel de Stan]]). Or il n'y a pas d'expression analytique ni pour la cumulative de la loi Multinomiale ni pour la loi de Dirichlet. Nous sommes donc obligés de passer par de la likelihood-free inference:

#+begin_src python :session :async true
srng = np.random.default_rng()

def simulate(intentions, errs):
    r = srng.dirichlet(intentions)
    return r + errs

with pm.Model() as model:
    prior_intentions = np.array(
        [.5, 1.5, 9, 2.5, 1, 5, 7, 24, 17, 2.5, 13, 16, 1]
    )
    results_r = np.array(list(resultats.values())) / 100
    precision_r = precision / 100

    intentions = pm.Dirichlet('intentions', prior_intentions)
    errs = pm.Uniform("errs", -precision_r, precision_r, shape=(len(prior_intentions,)))
    result = pm.Simulator('result', simulate, params=(intentions, errs), epsilon=0.03, observed=results_r)

    trace = pm.sample_smc(kernel='ABC', chains=1, parallel=True, save_sim_data=True)
#+end_src


#+RESULTS:

#+begin_src python :session :results file :exports results :var filename=(org-babel-temp-file "figure" ".png")
import arviz as az
import matplotlib.pyplot as plt
az.plot_trace(trace[0])
plt.savefig(filename, bbox_inches='tight')
filename
#+end_src

#+RESULTS:
[[file:/tmp/babel-pSa1ZR/figureTLDmEo.png]]

#+begin_src python :session :results file :exports both :var filename=(org-babel-temp-file "figure" ".png")
intentions_r = {k: trace[0]['intentions'][:,i] for i,k in enumerate(resultats.keys())}
fig = src.intentions.plot(
    intentions_r,
    colors,
    "08/12/2021",
    "BVA pour Orange et RTL",
    title="Intentions de vote au premier tour",
    sample_size=num_exprimes,
    base="Certains d'aller voter et exprimant une opinion",
    logo_path="~/org/roam/images/logo.png"
)
plt.tight_layout()
plt.savefig(filename, dpi=600, bbox_inches="tight")
filename
#+end_src

#+attr_org: :width 600
#+RESULTS:
[[file:/tmp/babel-pSa1ZR/figuremnDc31.png]]

Il est difficile d'obtenir des résultats qui semblent correct. Pire, il est difficile d'estimer /si/ les résultats sont corrects. On fera sans pour le moment.
*** Distribution multinomiale comme modèle d'observation :model:

Je prends pour acquis depuis le début que le modèle Dirichlet-Dirichlet donne les mêmes résultats que le modèle Dirichlet-Multinomial correspondant, mais cela n'a rien d'évident.

J'ai rencontré l'idée la première fois dans cette [[https://liu.diva-portal.org/smash/get/diva2:945786/FULLTEXT01.pdf][thèse de master]] (3.1.2.5). Alors que la pertinence du modèle d'observation multinomial se justifie très bien ici, celle du modèle d'observation dirichlet pour les ratios est à confirmer (les résultats ont l'air semblables) mathématiquement.

Décidons d'abandonner le modèle Dirichlet-Dirichlet pour l'instant pour revenir à un modèle Dirichlet-Multinomial basique. On y inclut directement l'effet de l'arrondi, en disant que l'on n'oberver pas directement le ratio $r$ mais $\tilde{r}$ :

#+begin_src latex :results raw
\begin{align*}
  \boldsymbol{p} &\sim \operatorname{Dirichlet}(\boldsymbol{\alpha})\\
  \mathbf{n}  &\sim \operatorname{Multinomial}\left(\mathbf{p}, N)\\
  \mathbf{r}  &= \frac{\mathbf{n}}{N}\\
  \tilde{\mathbf{r}} &\sim \operatorname{Uniform}(\mathrm{r}-\delta, \mathrm{r}+\delta)\\
\end{align*}
#+end_src

#+RESULTS:
\begin{align*}
  \boldsymbol{p} &\sim \operatorname{Dirichlet}(\boldsymbol{\alpha})\\
  \mathbf{n}  &\sim \operatorname{Multinomial}\left(\mathbf{p}, N)\\
  \mathbf{r}  &= \frac{\mathbf{n}}{N}\\
  \tilde{\mathbf{r}} &\sim \operatorname{Uniform}(\mathrm{r}-\delta, \mathrm{r}+\delta)\\
\end{align*}

Le modèle s'implémente très facilement dans PyMC3:

#+begin_src python :session :async true
results_r = np.array(list(resultats.values())) / 100
precision_r = precision / 100

with pm.Model() as multinomial:
    prior_intentions = np.array(
        [.5, 1.5, 9, 2.5, 1, 5, 7, 24, 17, 2.5, 13, 16, 1]
    ) * 0.1
    p = pm.Dirichlet("intentions", prior_intentions, shape=(1,len(prior_intentions)))
    n = pm.Multinomial("respondants", num_exprimes, p, shape=(1, len(prior_intentions)))
    r = n / num_exprimes
    r_obs = pm.Uniform('observed', r-precision_r, r+precision_r, observed=results_r)

    trace = pm.sample()
#+end_src

#+RESULTS:
: /tmp/babel-o4KxvM/python-YhPue2

#+begin_src python :session :results file :exports results :var filename=(org-babel-temp-file "figure" ".png")
import arviz as az
import matplotlib.pyplot as plt
az.plot_trace(trace)
plt.savefig(filename, bbox_inches='tight')
filename
#+end_src

#+RESULTS:
[[file:/tmp/babel-OuSpkx/figure8HnRPR.png]]

#+begin_src python :session :results file :exports both :var filename=(org-babel-temp-file "figure" ".png")
intentions_r = {k: trace['intentions'][:,0, i] for i,k in enumerate(resultats.keys())}
fig = src.intentions.plot(
    intentions_r,
    colors,
    "08/12/2021",
    "BVA pour Orange et RTL",
    title="Intentions de vote au premier tour",
    sample_size=num_exprimes,
    base="Certains d'aller voter et exprimant une opinion",
    logo_path="~/org/roam/images/logo.png"
)
plt.tight_layout()
plt.savefig(filename, dpi=600, bbox_inches="tight")
filename
#+end_src

#+attr_org: :width 500
#+RESULTS:
[[file:/tmp/babel-OuSpkx/figureFMPKS0.png]]

On voit que les intervalles de confiance sont légèrement élargis. /Supposons maintenant que les résultats sont données à plus ou moins un point près!

#+begin_src python :session :async true
results_r = np.array(list(resultats.values())) / 100
precision_r = 1. / 100

with pm.Model() as multinomial:
    prior_intentions = np.array(
        [.5, 1.5, 9, 2.5, 1, 5, 7, 24, 17, 2.5, 13, 16, 1]
    )
    p = pm.Dirichlet("intentions", prior_intentions, shape=(1,len(prior_intentions)))
    n = pm.Multinomial("respondants", num_exprimes, p, shape=(1, len(prior_intentions)))
    r = n / num_exprimes
    r_obs = pm.Uniform('observed', r-precision_r, r+precision_r, observed=results_r)

    trace = pm.sample()
#+end_src

#+RESULTS:

#+begin_src python :session :results file :exports results :var filename=(org-babel-temp-file "figure" ".png")
import arviz as az
import matplotlib.pyplot as plt
az.plot_trace(trace)
plt.savefig(filename, bbox_inches='tight')
filename
#+end_src

#+RESULTS:
[[file:/tmp/babel-OuSpkx/figureqJfd6w.png]]

#+begin_src python :session :results file :exports both :var filename=(org-babel-temp-file "figure" ".png")
intentions_r = {k: trace['intentions'][:,0, i] for i,k in enumerate(resultats.keys())}
fig = src.intentions.plot(
    intentions_r,
    colors,
    "08/12/2021",
    "BVA pour Orange et RTL",
    title="Intentions de vote au premier tour",
    sample_size=num_exprimes,
    base="Certains d'aller voter et exprimant une opinion",
    logo_path="~/org/roam/images/logo.png"
)
plt.tight_layout()
plt.savefig(filename, dpi=600, bbox_inches="tight")
filename
#+end_src

#+attr_org: :width 500
#+RESULTS:
[[file:/tmp/babel-OuSpkx/figureruPQ86.png]]

** TODO Nouvelle représentation des indécis, etc :viz:
    - Pour la présentation brute mettre les gens qui n'expriment pas d'intention de vote sur la courbe
    - Avec les gens sûrs de leur choix mettre le % d'indécis en plus
    - Pour mettre opinions brutes et certains de leur choix sur le meme graphe:
      Superposer les intervalles, avec un rond creux pour les certains d'aller voter
** TODO Pécresse dans les nouveaux sondages :edito:
** TODO Pairwise comparisons :viz:
[2021-12-14 Tue]

Randomly scattering points does not give great results. can probably improve the layout using /blue noise/. The idea to get a good enough plot (we're not aiming for accuracy on *these* plots) would be to:

1. [[https://github.com/rougier/scientific-visualization-book/blob/master/code/beyond/bluenoise.py][Generate]] a set of points $N_p$ st $N_p \gg 100$ between -20% et +20%
2. For each simulation, find the point with the closest x value. Set to occupied.
3. Then only display the occupied circles.

Also, the exact

#+begin_src python :session :results silent
from math import cos, sin, floor, sqrt, pi, ceil

def generate_blue_noise(shape, radius, k=32, seed=None):
    """Generate blue noise over a two-dimensional rectangle of size (width,height)

    This code was copied from Nicolas Rougier's repo at https://github.com/rougier/scientific-visualization-book.

    Parameters
    ----------
    shape : tuple
        Two-dimensional domain (width x height)
    radius : float
        Minimum distance between samples
    k : int, optional
        Limit of samples to choose before rejection (typically k = 30)
    seed : int, optional
        If provided, this will set the random seed before generating noise,
        for valid pseudo-random comparisons.

    References
    ----------
    .. [1] Fast Poisson Disk Sampling in Arbitrary Dimensions, Robert Bridson,
           Siggraph, 2007. :DOI:`10.1145/1278780.1278807`

    """
    def sqdist(a, b):
        """ Squared Euclidean distance """
        dx, dy = a[0] - b[0], a[1] - b[1]
        return dx * dx + dy * dy

    def grid_coords(p):
        """ Return index of cell grid corresponding to p """
        return int(floor(p[0] / cellsize)), int(floor(p[1] / cellsize))

    def fits(p, radius):
        """ Check whether p can be added to the queue """

        radius2 = radius * radius
        gx, gy = grid_coords(p)
        for x in range(max(gx - 2, 0), min(gx + 3, grid_width)):
            for y in range(max(gy - 2, 0), min(gy + 3, grid_height)):
                g = grid[x + y * grid_width]
                if g is None:
                    continue
                if sqdist(p, g) <= radius2:
                    return False
        return True

    # When given a seed, we use a private random generator in order to not
    # disturb the default global random generator
    if seed is not None:
        from numpy.random.mtrand import RandomState

        rng = RandomState(seed=seed)
    else:
        rng = np.random

    width, height = shape
    cellsize = radius / sqrt(2)
    grid_width = int(ceil(width / cellsize))
    grid_height = int(ceil(height / cellsize))
    grid = [None] * (grid_width * grid_height)

    p = rng.uniform(0, shape, 2)
    queue = [p]
    grid_x, grid_y = grid_coords(p)
    grid[grid_x + grid_y * grid_width] = p

    while queue:
        qi = rng.randint(len(queue))
        qx, qy = queue[qi]
        queue[qi] = queue[-1]
        queue.pop()
        for _ in range(k):
            theta = rng.uniform(0, 2 * pi)
            r = radius * np.sqrt(rng.uniform(1, 4))
            p = qx + r * cos(theta), qy + r * sin(theta)
            if not (0 <= p[0] < width and 0 <= p[1] < height) or not fits(p, radius):
                continue
            queue.append(p)
            gx, gy = grid_coords(p)
            grid[gx + gy * grid_width] = p

    return np.array([p for p in grid if p is not None])
#+end_src

#+begin_src python :session :results file :exports both :var filename=(org-babel-temp-file "figure" ".png")
import imageio
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as grid_spec
import scipy.stats as stats


srng = np.random.default_rng(seed=0)

def scatter_points(x):
    return 0.10 * (1-2*srng.random(len(x)))

def scatter_random(x):
    y = scatter_points(x)
    for _ in range(10_000):
        z = np.array([complex(x[i], y[i]) for i in range(100)])
        m, n = np.meshgrid(z, z)
        distances = abs(m-n) + 100 * np.eye(100)
        min_idxs = np.where(distances == np.min(distances))[0]
        idx = srng.choice(min_idxs)
        new_y = 0.10 * (1-2*srng.random())
        if abs(new_y) < 0.03:
            y[idx] = new_y
    return y

pairs = [("Mélenchon", "Jadot"), ("Le Pen", "Pécresse"), ("Zemmour", "Le Pen"), ("Macron", "Le Pen")]
num_pairs = len(pairs)

gs = grid_spec.GridSpec(num_pairs, 1)
fig = plt.figure()
axes = []

for i, candidates in enumerate(pairs):
    axes.append(fig.add_subplot(gs[i:i+1, 0:]))

    diff = intentions_r[candidates[1]]-intentions_r[candidates[0]]
    num_wins = int(100 * np.sum(diff>0) / len(diff))
    x = 100 * srng.choice(diff, 100)
    y = scatter_random(x)

    condlist = [x>0, x<0]
    choicelist = [colors[candidates[1]], colors[candidates[0]]]
    colors_points = np.select(condlist, choicelist)

    # transparent background
    rect = axes[-1].patch
    rect.set_alpha(0)

    # remove borders, ticks and labels
    axes[-1].set_yticklabels([])
    axes[-1].set_ylabel("")
    axes[-1].yaxis.set_ticks_position("none")

    axes[-1].set_xticklabels([])
    axes[-1].xaxis.set_ticks_position("none")

    spines = ["top", "right", "left", "bottom"]
    for s in spines:
        axes[-1].spines[s].set_visible(False)

    axes[-1].scatter(x, y, c=colors_points, s=50, edgecolor="white", zorder=2)
    axes[-1].axvline(0, color="black", lw=2)
    axes[-1].axvline(5, ymin=0.1, color="lightgray", lw=0.5)
    axes[-1].axvline(10, ymin=0.1, color="lightgray", lw=0.5)
    axes[-1].axvline(-5, ymin=0.1, color="lightgray", lw=0.5)
    axes[-1].axvline(-10, ymin=0.1, color="lightgray", lw=0.5)

    lim_left = min(min(x) - 1, -1)
    lim_right = max(1 + max(x), 1)

    axes[-1].text(
        lim_right,
        0.0,
        f"{candidates[1]} en tête",
        fontweight="normal",
        fontname="Futura PT",
        va="center",
        ha="left",
        fontsize=15,
        color=colors[candidates[1]],
    )
    axes[-1].text(
        lim_right,
        -0.1,
        f"{num_wins} sur 100",
        fontweight="bold",
        fontname="Futura PT",
        va="center",
        ha="left",
        fontsize=20,
        color=colors[candidates[1]],
    )
    axes[-1].text(
        lim_left,
        0.0,
        f"{candidates[0]} en tête",
        fontweight="bold",
        fontname="Futura PT",
        va="center",
        ha="right",
        fontsize=15,
        color=colors[candidates[0]],
    )
    axes[-1].text(
        lim_left,
        -0.1,
        f"{100-num_wins} sur 100",
        fontweight="bold",
        fontname="Futura PT",
        va="center",
        ha="right",
        fontsize=20,
        color=colors[candidates[0]],
    )

    """
    axes[-1].text(
        0,
        -0.04,
        f"Égalité",
        fontweight="light",
        fontname="Futura PT",
        va="top",
        ha="center",
        fontsize=16,
        color="black",
    )
    axes[-1].text(
        5,
        -0.04,
        f"+5%",
        fontweight="light",
        fontname="Futura PT",
        va="bottom",
        ha="center",
        fontsize=20,
        color=colors[candidates[1]],
    )
    axes[-1].text(
        -5,
        -0.04,
        f"+5%",
        fontweight="light",
        fontname="Futura PT",
        va="bottom",
        ha="center",
        fontsize=20,
        color=colors[candidates[0]],
    )
    """
    axes[-1].set_ylim(-0.20, 0.20)
    axes[-1].set_xlim(-15, 10)


#ax1 = fig.add_axes([-0.15, 0.95, 0.15, 0.15])
#im = imageio.imread("~/org/roam/images/logo.png")
#ax1.imshow(im)
#ax1.axis("off")

gs.update(hspace=-0.1)

plt.savefig(filename, dpi=100, bbox_inches="tight")
filename
#+end_src

#+attr_org: :width 800
#+RESULTS:
[[file:/tmp/babel-VWjkW3/figureARmrYu.png]]


**** TODO Ajouter légende sur le graphe
**** TODO Placer points avec blue noise
**** TODO Compute location of vertical lines automatically

** TODO Add latest polls :data:
** TODO Clean the database on github :data:
** TODO Use ridgeline plots to show evolution of vote for Pécresse for instance :viz:
 See [[https://clauswilke.com/dataviz/boxplots-violins.html][Figure 9.12]] here, very beautiful.
